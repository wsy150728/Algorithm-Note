排序算法

        排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，
    一次不能容纳全部的排序记录，在排序过程中需要访问外存。

八大内部排序算法   
* 插入排序-直接插入排序
* 插入排序-希尔排序
* 选择排序-简单选择排序
* 选择排序-堆排序
* 交换排序-冒泡排序
* 交换排序-快速排序
* 归并排序
* 基数排序

1.插入排序-直接插入排序(insertSort)

    基本思想：将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。
    
    操作方法：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。
    
    要点：设立哨兵，作为临时存储和判断数组边界之用。
    
    如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，
    从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。
    
    效率:时间复杂度：O（n^2）. 
    
    
2.插入排序-希尔排序(shellSort)

    基本思想：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体
    记录进行依次直接插入排序。希尔排序又叫缩小增量排序。
    
    操作方法:
        1.选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
        2.按增量序列个数k，对序列进行k 趟排序；
        3.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 
          时，整个序列作为一个表来处理，表长度即为整个序列的长度。
          
    希尔排序是不稳定排序。
    
    2．Shell排序的时间性能优于直接插入排序
        希尔排序的时间性能优于直接插入排序的原因：
    　　①当文件初态基本有序时直接插入排序所需的比较和移动次数均较少。
    　　②当n值较小时，n和n2的差别也较小，即直接插入排序的最好时间复杂度O(n)和最坏时间复杂度0(n2)差别不大。
    　　③在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来增量di逐渐缩小，分组数逐渐减少，
        而各组的记录数目逐渐增多，但由于已经按di-1作为距离排过序，使文件较接近于有序状态，所以新的一趟排序过程也较快。
        
        因此，希尔排序在效率上较直接插人排序有较大的改进。
        
    效率:时间复杂度：O（n^2）.
    
3.选择排序—简单选择排序（Simple Selection Sort）
    
    基本思想：在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）
    的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。
    
    操作方法：
        1.第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换；
        2.第二趟，从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换；
        3.以此类推.....
        4.第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换，
        5.直到整个序列按关键码有序。
        
    效率:时间复杂度是O(n^2)  
    
    尽管与冒泡排序同为O(n^2)，但选择排序的性能还是略优于冒泡排序的。
    
    简单选择排序的改进——二元选择排序
        在同一趟寻找最小值的同时也找到最大值，这样会少循环一半的时间。
        
        
4.选择排序—堆排序（Heap Sort）
    
    堆排序：是一种特殊形式的选择排序，他是简单选择排序的一种改进。
    什么是堆？
        具有n个元素的序列：{k1,k2,ki,…,kn} (ki <= k2i,ki <= k2i+1) 或者 (ki >= k2i,ki >= k2i+1), (i = 1,2,3,4...n/2)
    满足这个条件时，该序列就是一个堆。第一个条件称为小顶堆，第二个条件称为大顶堆。
    
    为了方便，下边论述基于大顶堆，并且下标从1开始。
    将堆的元素放在一棵完全二叉树中，方便我们讨论堆的特性和排序，一般谈到堆也都是一棵完全二叉树。
    完全二叉树：若二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。
    堆的特性（括号道标下标从0开始的计算方法） ：
        非叶子结点个数：n / 2 （n / 2 - 1）
        节点i的左子树下标 ：2*i （2*i+ 1）
        节点i的右子树下标：2*i + 1 （2*i + 2）
    
    核心思想：    
        将原始序列构成一个堆。（建立初始堆）
        交换堆的第一个元素（最大值）和最后一个元素的位置，把堆长度减一后剩余的序列再转换为一个堆。（调整堆）
        重复2过程n-1次。
    
    经过上述操作，就可以将一个无序序列从小到大排序。（因为大顶堆每次把最大值交换到最后了,所以想要降序排列就要用小顶堆）
    
        先说调堆，调堆就是把当前节点和其左子树，右子树中最大值交换，依次把需要调整的节点调一遍。这样一次循环下来根节点肯
    定放的是最大值。但是有可能循环中的某次交换把之前排好序的结构打乱，需要递归调整。 
        再说建堆，建堆就是从最后一个非叶子节点开始，到第一个节点为止，依次进行调堆。
    
    堆排序平均效率,最好效率,最坏效率均为O(nlog|2为底|n)
    
5.交换排序—冒泡排序（Bubble Sort）
    
    基本思想：在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数
    往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。
    
    冒泡排序算法的改进
        对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没
    有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。本文再提供以下两种改进算法：

        1．设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序
    时只要扫描到pos位置即可。
        2．传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可
    以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。
    
    稳定，时间复杂度:O(n^2)

6.交换排序—快速排序（Quick Sort）

    基本思想：
    1）选择一个基准元素,通常选择第一个元素或者最后一个元素,
    2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。  
    3）此时基准元素在其排好序后的正确位置
    4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。
    
    使用递归，则需要找到递归点和递归出口：
    递归点：如果数组的元素大于1，就需要再进行分解，所以我们的递归点就是新构造的数组元素个数大于1
    递归出口：我们什么时候不需要再对新数组不进行排序了呢？就是当数组元素个数变成1的时候，所以这就是我们的出口。
    
    快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序
    反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调
    整为支点记录。快速排序是一个不稳定的排序方法。
    
    快速排序的改进
    
    在本改进算法中,只对长度大于k的子序列递归调用快速排序,让原序列基本有序，然后再对整个基本有序序列用插入排序算法排序。
    实践证明，改进后的算法时间复杂度有所降低，且当k取值为 8 左右时,改进算法的性能最佳。
    
    

    